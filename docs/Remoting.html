<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Remoting | Bolero: F# in WebAssembly</title>
  <link rel="icon" type="image/png" href="/img/favicon-16x16.png" sizes="16x16" />
  <link rel="icon" type="image/png" href="/img/favicon-32x32.png" sizes="32x32" />
  <meta id='websharper-data' name='websharper-data' content='{"$TYPES":[],"$DATA":{"$V":{}}}' />

  <link rel="stylesheet" href="/css/all.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/highlight.min.js" type="text/javascript" charset="UTF-8"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/languages/fsharp.min.js" type="text/javascript" charset="UTF-8"></script><link type="text/css" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/styles/vs.min.css"></link>

</head>
<body>
  <header class="navbar overlay-bar">
    <div class="navbar-brand">
      <a class="navbar-item is-hoverable" onclick="Website.Client.ToggleDrawer()"><i class="fa fa-bars"></i></a>
      <span class="navbar-item"><a href="/">Bolero</a></span>
    </div>
    <div class="navbar-menu">
      <nav class="navbar-end"><a href="/" class="navbar-item is-hoverable has-text-weight-bold">Home</a><a href="/docs" class="navbar-item is-hoverable has-text-weight-bold">Documentation</a><a href="/blog" class="navbar-item is-hoverable has-text-weight-bold">Blog</a><a href="https://tryfsharp.fsbolero.io" class="navbar-item is-hoverable has-text-weight-bold">Try F#</a></nav>
    </div>
  </header>
  <div class="drawer-backdrop" onclick="Website.Client.ToggleDrawer()">
    <div id="left-drawer" class="lhs-drawer">
      <span class="navbar-item"><a href="/">Bolero</a></span>
      <nav><a href="/" class="navbar-item nav-menu-link">Home</a><a href="/docs" class="navbar-item nav-menu-link">Documentation</a><a href="/blog" class="navbar-item nav-menu-link">Blog</a><a href="https://tryfsharp.fsbolero.io" class="navbar-item nav-menu-link">Try F#</a></nav>
    </div>
  </div>
  
      <section class="hero is-dark page-banner">
        <div class="hero-body has-text-centered">
          <h1 class="title is-spaced">Bolero</h1>
        </div>
      </section>
      <section class="section">
        <div class="container">
          <div class="columns">
            <div class="column is-one-quarter"><div ws-preserve=""><div class="menu"><p class="menu-label">
Documentation</p>
<ul class="menu-list">
<li><a href="/docs">Getting Started</a></li>
<li><a href="/docs/HTML">Writing HTML</a></li>
<li><a href="/docs/Templating">HTML templates</a></li>
<li><a href="/docs/Elmish">Using Elmish</a></li>
<li><a href="/docs/Routing">Routing</a></li>
<li><a href="/docs/Remoting">Remoting</a></li>
</ul>
</div>
<!-- DOCTOC SKIP -->
</div></div>
            <div class="column content markdown-column"><div ws-preserve=""><p>Bolero.Remoting provides the ability to easily call server-side functions from the client side.</p>
<p>Remote calls are <code>POST</code> requests to a specific URL. Arguments and return values are automatically serialized to JSON.</p>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<ul>
<li><a href="#defining-the-service">Defining the service</a></li>
<li><a href="#calling-on-the-client-side">Calling on the client side</a></li>
<li><a href="#defining-on-the-server-side">Defining on the server side</a>
<ul>
<li><a href="#a-simple-service">A simple service</a></li>
<li><a href="#using-dependency-injection">Using dependency injection</a></li>
<li><a href="#using-several-services">Using several services</a></li>
</ul>
</li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h1 id="defining-the-service">Defining the service</h1>
<p>A set of server-side functions is defined as a record called a <em>remote service</em>. Each function is a field in this record, and must take one argument and return <code>Async&lt;_&gt;</code>. If you need to pass several arguments to a server-side function, use a tuple.</p>
<p>The record should implement <code>IRemoteService</code> to define the URL for its functions. Each function is served at the path <code>&lt;service.BasePath&gt;/&lt;fieldName&gt;</code>.</p>
<p>For example, here is the definition of a service for a simple key-value pair storage:</p>
<pre><code class="language-fsharp">open Bolero.Remoting

type MyService =
    {
        getEntry : string -&gt; Async&lt;option&lt;string&gt;&gt;  // Served at /myService/getEntry
        setEntry : string * string -&gt; Async&lt;unit&gt;   // Served at /myService/setEntry
        deleteEntry : string -&gt; Async&lt;unit&gt;         // Served at /myService/deleteEntry
    }

    interface IRemoteService with
        member this.BasePath = &quot;/myService&quot;
</code></pre>
<h1 id="calling-on-the-client-side">Calling on the client side</h1>
<p>On the client side, you will typically want to call these functions in the <code>update</code> of the Elmish app. See <a href="https://elmish.github.io/elmish/basics.html">the Elmish documentation</a> to learn how to run commands in <code>update</code>.</p>
<ol>
<li><p>In your Blazor startup (<code>Client/Startup.fs</code>), add support for remoting:</p>
<pre><code class="language-fsharp">open Bolero.Remoting

type Startup() =

    member __.ConfigureServices(services: IServiceCollection) =
        services.AddRemoting()
        |&gt; ignore
</code></pre>
</li>
<li><p>Retrieve the client-side service in the <code>ProgramComponent</code> by using <code>this.Remote</code>:</p>
<pre><code class="language-fsharp">type App() =
    inherit ProgramComponent&lt;Model, Message&gt;()

    override this.Program =
        // Retrieve the service
        let myService = this.Remote&lt;MyService&gt;()
        // Pass it to `update`
        Program.mkProgram (fun _ -&gt; initModel, []) (update myService) view
</code></pre>
</li>
<li><p>In <code>update</code>, use the service in <code>Cmd</code>s:</p>
<pre><code class="language-fsharp">type Model = { latestRetrievedEntry : string * string }

type Message =
    // Trigger a `getEntry` request
    | GetEntry of key: string
    // Received response of a `getEntry` request
    | GotEntry of key: string * value: string
    // A request threw an error
    | Error of exn

let update myService message model =
    match message with
    | GetEntry key -&gt;
        model,
        Cmd.ofAsync
            myService.getEntry key              // async call and argument
            (fun value -&gt; GotEntry(key, value)) // message to dispatch on response
            Error                               // message to dispatch on error
    | GotEntry(key, value) -&gt;
        { model with latestRetrievedEntry = (key, value) }, []
    | Error exn -&gt;
        model, []
</code></pre>
</li>
</ol>
<h1 id="defining-on-the-server-side">Defining on the server side</h1>
<p>On the server side, Bolero.Remoting is registered as a service and added as ASP.NET Core middleware. There are several ways to do so.</p>
<h2 id="a-simple-service">A simple service</h2>
<p>Here is how to implement a remote service without any dependencies.</p>
<ol>
<li><p>Implement the service as a value:</p>
<pre><code class="language-fsharp">// A simple global map as storage.
// A real-world app would probably use a database instead.
let mutable storage = Map.empty

let myService =
    {
        getEntry = fun key -&gt; async {
            return Map.tryFind key
        }
        setEntry = fun (key, value) -&gt; async {
            storage &lt;- Map.add key value storage
        }
        deleteEntry = fun key -&gt; async {
            storage &lt;- Map.remove key storage
        }
    }
</code></pre>
</li>
<li><p>In your ASP.NET Core startup (<code>Server/Startup.fs</code>), register the service:</p>
<pre><code class="language-fsharp">type Startup() =

    member this.ConfigureServices(services: IServiceCollection) =
        services.AddRemoting(myService)
        |&gt; ignore
</code></pre>
</li>
<li><p>In your ASP.NET Core startup, start the remoting middleware:</p>
<pre><code class="language-fsharp">type Startup() =

    member this.Configure(app: IApplicationBuilder) =
        app.UseRemoting()
            .UseBlazor&lt;Client.Startup&gt;()
        |&gt; ignore
</code></pre>
<p>Note that <code>UseRemoting</code> (and any other middleware) must be called <em>before</em> <code>UseBlazor</code>, because <code>UseBlazor</code> unconditionally catches all requests.</p>
</li>
</ol>
<h2 id="using-dependency-injection">Using dependency injection</h2>
<p>You might need to use injected dependencies in a remote service: a logger, a database connection, etc. For this, you need a different approach.</p>
<ol>
<li><p>Implement the service as a class inheriting from <code>RemoteHandler</code>. Dependencies can be injected from the constructor.</p>
<pre><code class="language-fsharp">type MyServiceHandler(log: ILogger&lt;MyServiceHandler&gt;) =
    inherit RemoteHandler&lt;MyService&gt;()

    let mutable storage = Map.empty

    override this.Handler =
        {
            getEntry = fun key -&gt; async {
                log.LogInformation(&quot;Retrieving {0}&quot;, key)
                return Map.tryFind key
            }
            setEntry = fun (key, value) -&gt; async {
                log.LogInformation(&quot;Setting {0} to {1}&quot;, key, value)
                storage &lt;- Map.add key value storage
            }
            deleteEntry = fun key -&gt; async {
                log.LogInformation(&quot;Deleting {0}&quot;, key)
                storage &lt;- Map.remove key storage
            }
        }
</code></pre>
</li>
<li><p>In your ASP.NET Core startup, register the service by type rather than by instance:</p>
<pre><code class="language-fsharp">type Startup() =

    member this.ConfigureServices(services: IServiceCollection) =
        services.AddRemoting&lt;MyServiceHandler&gt;()
        |&gt; ignore
</code></pre>
</li>
</ol>
<h2 id="using-several-services">Using several services</h2>
<p>You can of course define several remote services in the same application. Each of them needs to be registered by a separate call to <code>AddRemoting</code> in <code>ConfigureServices</code>. A single call to <code>UseRemoting</code> is enough in <code>Configure</code>.</p>
</div></div>
          </div>
        </div>
      </section>
    
  <script src="https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/8.6.0/lazyload.min.js"></script>
  <script type="text/javascript">new LazyLoad();</script>
  <script src="/js/Client.min.js"></script>
  
  
</body>
</html>